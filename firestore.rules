/**
 * # Firestore Security Rules
 *
 * ## Core Philosophy
 * This ruleset enforces a strict user-ownership model. All user data is private and stored in a document that can only be accessed by the authenticated user who owns it. The default security posture is to deny all access unless explicitly granted.
 *
 * ## Data Structure
 * The data is organized in a single top-level collection: `/users`. Each user's profile and related data are stored in a document where the document ID matches the user's Authentication UID (e.g., `/users/{userId}`).
 *
 * ## Key Security Decisions
 * - **No User Listing:** To protect user privacy, it is impossible for any client to list all documents in the `/users` collection, unless they are an admin.
 * - **Strict Ownership:** A user can only read, create, update, or delete their own document within the `/users` collection. Admins have broader access.
 * - **Path-Based Security:** Authorization is primarily determined by matching the `request.auth.uid` with the `{userId}` wildcard in the document path.
 *
 * ## Denormalization for Authorization
 * This security model is simple and does not require complex denormalization. The user's role is stored directly on their user document.
 *
 * ## Structural Segregation
 * Not applicable in this model, as all user data is considered private. There is no mix of public and private data within the same collection.
 */
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // --- Helper Functions ---

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the currently authenticated user's UID matches the provided userId.
     * This is the primary function for enforcing document ownership.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Checks for ownership on an existing document.
     * CRITICAL: Ensures update/delete operations target real documents, preventing errors
     * and unintended behavior on non-existent paths.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    function isRole(role) {
      return isSignedIn() && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == role;
    }

    function isTeacher() {
      return isRole('teacher');
    }

    function isAdmin() {
      return isRole('admin');
    }

    /**
     * Validates critical relational data when a user document is created.
     * In prototyping mode, we only validate fields essential for authorization and
     * path consistency, not the entire data shape.
     */
    function hasValidAndConsistentUserDataOnCreate(userId) {
      // Enforces that the document's internal `id` field matches its path ID (`userId`).
      // This creates a consistent and reliable link between the path and the data.
      return request.resource.data.id == userId;
    }

    /**
     * Enforces immutability for critical fields on update.
     * Prevents a user from changing their own document ID or Google ID after creation,
     * which are fundamental to their identity within the system.
     */
    function hasImmutableUserDataOnUpdate() {
      let incomingData = request.resource.data;
      let existingData = resource.data;
      return incomingData.id == existingData.id;
    }

    /**
     * @description Rules for a user's own profile document.
     * @path /users/{userId}
     */
    match /users/{userId} {
      // READ Rules: A user can only get their own document. Listing is disabled for non-admins.
      allow get: if isOwner(userId) || isAdmin();
      allow list: if isAdmin();

      // WRITE Rules: A user can create, update, and delete their own document. Admins can update any.
      allow create: if isOwner(userId) && hasValidAndConsistentUserDataOnCreate(userId);
      allow update: if isOwner(userId) || isAdmin();
      allow delete: if isExistingOwner(userId);
    }
    
    match /classes/{classId} {
      allow read: if isSignedIn();
      allow write: if isAdmin();
    }

    match /subjects/{subjectId} {
      allow read: if isSignedIn();
      allow write: if isAdmin();
    }

    match /units/{unitId} {
      allow read: if isSignedIn();
      allow write: if isAdmin();
    }

    match /categories/{categoryId} {
      allow read: if isSignedIn();
      allow write: if isAdmin();
    }

    match /questions/{questionId} {
      allow read: if isSignedIn();
      allow write: if isAdmin() || isTeacher();
    }

    match /worksheets/{worksheetId} {
      // A user can read a specific worksheet if they are its author. Admins can read any worksheet.
      allow get: if isOwner(resource.data.authorId) || isAdmin() || isSignedIn();
      
      // A user can list worksheets if their query is filtering by their own authorId, OR if they are querying by subjectId.
      allow list: if (request.query.keys().hasOnly(['authorId', 'subjectId', 'orderBy'])) ||
                      (request.query.keys().hasAny(['authorId', 'subjectId'])) && isSignedIn();
      
      // Teachers and Admins are allowed to create, update, and delete worksheets.
      allow write: if isTeacher() || isAdmin();
    }

    match /worksheet_attempts/{attemptId} {
      // READ: Admins/teachers can read any attempt. Users can only read their own.
      allow get: if isOwner(resource.data.userId) || isTeacher() || isAdmin();
      
      // LIST: Admins can list all attempts. Users can only list attempts matching their own UID.
      allow list: if isAdmin() || (request.query.userId == request.auth.uid);

      // WRITE: Users can create their own attempt. No one can update/delete.
      allow create: if isOwner(request.resource.data.userId);
      allow update, delete: if false;
    }

    match /settings/{settingId} {
        allow read: if isSignedIn();
        allow write: if isAdmin();
    }

    match /transactions/{transactionId} {
      // A user can create their own transactions (e.g. through a server-side function)
      // For now, let's restrict client-side creation for safety
      allow create: if isOwner(request.resource.data.userId);
      
      // A user can only list/read their own transactions.
      allow get: if isOwner(resource.data.userId) || isAdmin();
      allow list: if request.query.keys().hasOnly(['userId', 'orderBy']) &&
                   request.query.userId == request.auth.uid;

      // Transactions are immutable.
      allow update, delete: if false;
    }
  }
}
