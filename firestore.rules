
/**
 * # Firestore Security Rules
 *
 * ## Core Philosophy
 * This ruleset enforces a strict user-ownership model. All user data is private and stored in a document that can only be accessed by the authenticated user who owns it. The default security posture is to deny all access unless explicitly granted.
 */
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // ==========================================
    // 1. HELPER FUNCTIONS
    // ==========================================

    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    function isRole(role) {
      return isSignedIn() && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == role;
    }

    function isTeacher() {
      return isRole('teacher');
    }

    function isAdmin() {
      return isRole('admin');
    }

    /**
     * ✅ NEW: Checks if user's role has a specific permission.
     * Reads from the /settings/permissions document.
     */
    function hasPermission(permissionKey) {
      // Admin always has permission, regardless of the doc.
      if (isAdmin()) { return true; }
      
      let userRole = get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role;
      let permissionDoc = get(/databases/$(database)/documents/settings/permissions).data;
      
      // Check if the permissionKey exists and if the user's role is in the array.
      return permissionKey in permissionDoc && userRole in permissionDoc[permissionKey];
    }

    function hasValidAndConsistentUserDataOnCreate(userId) {
      return request.resource.data.id == userId;
    }

    function hasImmutableUserDataOnUpdate() {
      let incomingData = request.resource.data;
      let existingData = resource.data;
      return incomingData.id == existingData.id;
    }

    /**
     * Checks if the only field being updated is 'rewardsClaimed' from false to true.
     * This prevents any other modification to the historical attempt data.
     */
    function isClaimingRewards() {
      // The update request should only contain the 'rewardsClaimed' field.
      // size() == 1 means only one field is being changed.
      return request.resource.data.diff(resource.data).affectedKeys().hasOnly(['rewardsClaimed']) &&
             request.resource.data.rewardsClaimed == true &&
             resource.data.rewardsClaimed == false;
    }


    // ==========================================
    // 2. COLLECTION RULES
    // ==========================================

    /**
     * Users Collection
     */
    match /users/{userId} {
      allow get: if isOwner(userId) || isAdmin();
      allow list: if isAdmin();
      allow create: if isOwner(userId) && hasValidAndConsistentUserDataOnCreate(userId);
      // ✅ Allow users to update their own coupon status
      allow update: if (isOwner(userId) && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['lastCouponClaimedAt', 'hasClaimedWelcomeCoupon'])) || isAdmin();
      allow delete: if isExistingOwner(userId);
    }
     
    // Static Metadata Collections
    match /classes/{classId} {
      allow read: if isSignedIn();
      allow write: if isAdmin();
    }

    match /subjects/{subjectId} {
      allow read: if isSignedIn();
      allow write: if isAdmin();
    }

    match /units/{unitId} {
      allow read: if isSignedIn();
      allow write: if isAdmin();
    }

    match /categories/{categoryId} {
      allow read: if isSignedIn();
      allow write: if isAdmin();
    }

    /**
     * Questions Collection
     * ✅ UPDATED: Use dynamic permission
     */
    match /questions/{questionId} {
      allow read: if isSignedIn();
      allow write: if hasPermission('question_create');
    }

    /**
     * Worksheets Collection
     */
    match /worksheets/{worksheetId} {
      // ✅ UPDATED: Read uses dynamic permission
      allow get: if hasPermission('worksheet_read');
      allow list: if isSignedIn() && (hasPermission('worksheet_read') || request.query.subjectId == resource.data.subjectId);
      
      // ✅ UPDATED: Create uses dynamic permission
      allow create: if hasPermission('worksheet_create') ||
                       (request.resource.data.worksheetType == 'practice' && isOwner(request.resource.data.authorId));

      // ✅ UPDATED: Update/Delete uses dynamic permission
      allow update, delete: if hasPermission('worksheet_delete');
    }

    /**
     * Worksheet Attempts
     */
    match /worksheet_attempts/{attemptId} {
      allow create: if isOwner(request.resource.data.userId);
      allow read: if isOwner(resource.data.userId) || hasPermission('worksheet_read');
      allow list: if (request.query.keys().hasOnly(['userId', 'worksheetId', 'limit', 'orderBy', 'attemptedAt']) && request.query.userId == request.auth.uid) || hasPermission('worksheet_read');
      allow update: if isOwner(resource.data.userId) && (isClaimingRewards() || request.resource.data.diff(resource.data).affectedKeys().hasOnly(['unlockedSolutions']));
      allow delete: if false; // Deleting history is not allowed.
    }

    /**
     * Global Settings
     */
    match /settings/{settingId} {
        allow read: if isSignedIn();
        allow write: if isAdmin();
    }

    /**
     * Transactions Collection
     * ✅ UPDATED: Use dynamic permission for read/create
     */
    match /transactions/{transactionId} {
      allow create: if isOwner(request.resource.data.userId) || hasPermission('transaction_create');
      allow get: if isOwner(resource.data.userId) || hasPermission('transaction_view');
      allow list: if (request.query.keys().hasOnly(['userId', 'orderBy']) &&
                   request.query.userId == request.auth.uid) || hasPermission('transaction_view');
      allow update, delete: if false;
    }
  }
}
